<!DOCTYPE html>
<html>

<head>
<title>Gallery</title>

<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/webgl-debug.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-matrix.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/cuon-utils.js"></script>
<script src="https://www.ecst.csuchico.edu/~oal-saadi/Graphics/lib/load-object.js"></script>
<script>

var SHADOW_VSHADER_SOURCE =
  `attribute vec4 a_Position;
  uniform mat4 u_MvpMatrix;
  void main() {
    gl_Position = u_MvpMatrix * a_Position;
  }`;

var SHADOW_FSHADER_SOURCE =
  `precision mediump float;
  void main() {
    gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0); // Write the z-value in R
  }`;

var VSHADER_SOURCE =
    `
    precision mediump int;
    precision mediump float;
    attribute vec4 a_Position;
    attribute vec4 a_Color;
    attribute vec3 a_Normal;
    attribute vec2 a_UV;
    attribute vec3 a_Tangent;
    attribute vec3 a_Bitangent;
    varying vec4 v_Position;
    varying vec4 v_Color;
    varying vec4 v_PositionFromLight;
    varying vec3 v_Normal;
    varying vec2 v_UV;
    varying mat3 v_TBN;
    uniform int u_Count;
    uniform mat4 u_ModelMatrix;
    uniform mat4 u_ViewMatrix;
    uniform mat4 u_ProjMatrix;
    uniform mat4 u_MvpMatrixFromLight;
    mat3 TBN; 
    void main() {
        gl_Position = u_ProjMatrix * u_ViewMatrix * u_ModelMatrix * a_Position;
        v_Position = u_ModelMatrix * a_Position;
        v_UV = a_UV;
        v_Color = a_Color;
        v_PositionFromLight = u_MvpMatrixFromLight * a_Position;
        if (u_Count == 1 || u_Count == 2 || u_Count == 3) {
            vec3 T = normalize(vec3(u_ModelMatrix * vec4(a_Tangent, 0.0)));
            vec3 B = normalize(vec3(u_ModelMatrix * vec4(a_Bitangent, 0.0)));
            vec3 N = normalize(vec3(u_ModelMatrix * vec4(a_Normal, 0.0)));
            //vec3 N = cross(B, T);
            v_Normal = normalize(N);
            TBN = mat3(T, B, N);
            v_TBN = TBN;
        }
        else if (u_Count == 0) {
            v_Normal = normalize(a_Position.xyz);
        }
    }
    `;
var FSHADER_SOURCE =
    `
    precision mediump int;
    precision mediump float;
    varying vec4 v_Position;
    varying vec4 v_PositionFromLight;
    varying vec4 v_Color;
    varying vec3 v_Normal;
    varying vec2 v_UV;
    varying mat3 v_TBN;
    uniform float u_Time;
    uniform int u_Count;
    uniform mat4 u_ModelMatrix;
    uniform mat4 u_MvpMatrixFromLight;
    uniform float u_CamPosX;
    uniform float u_CamPosY;
    uniform float u_CamPosZ;
    uniform samplerCube u_Skybox;
    uniform sampler2D u_Sampler;
    uniform sampler2D u_NormalMap;
    uniform sampler2D u_ShadowMap;
    float nDotL;

    void main() {
        vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5;
        vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);
        float depth = rgbaDepth.r;

        if (u_Count == 0) {
            gl_FragColor = textureCube(u_Skybox, v_Normal);
        }
        else if (u_Count == 1 || u_Count == 2 || u_Count == 3) {
            vec3 normal = normalize(v_Normal);
            vec3 newNormal = texture2D(u_NormalMap, v_UV).rgb;
            newNormal = normalize(newNormal * 2.0 - 1.0);
            newNormal.xyz = normalize(v_TBN * newNormal);
            normal = newNormal;

            vec3 ambient = vec3(0.8, 0.8, 0.72);
            vec3 lightDirection = normalize(vec3(0, 3.0, 5.0));
            lightDirection = normalize(lightDirection);
            nDotL = max(dot(lightDirection, normal), 0.0);
            vec3 dirLightColor = vec3(1.0, 0.9, 0.8);
            vec3 diffuse = dirLightColor * v_Color.rgb * nDotL;

            // https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/
            float cosTheta = clamp(dot(normal, lightDirection), 0.0, 1.0);
            float bias = 0.005 * tan(acos(cosTheta));
            bias = clamp(bias, 0.0, 0.01);
            //float visibility = (shadowCoord.z > depth + bias) ? 0.7 : 1.0;

            // PCF adapted from https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping
            float visibility = 0.0;
            vec2 texelSize = 1.0 / vec2(2048.0, 2048.0);
            for(int x = -1; x <= 1; ++x)
            {
                for(int y = -1; y <= 1; ++y)
                {
                    float pcfDepth = texture2D(u_ShadowMap, shadowCoord.xy + vec2(x, y) * texelSize).r; 
                    visibility += (shadowCoord.z > pcfDepth + bias) ? 0.7 : 1.0;        
                }    
            }
            visibility /= 9.0;

            vec3 toCamDir = normalize(vec3(u_CamPosX, u_CamPosY, u_CamPosZ) - v_Position.xyz);
            vec3 reflectedLightDir = reflect(-lightDirection, normal);
            vec3 specularColor = vec3(1.0, 1.0, 1.0);
            float specularBase = 0.0;
            if (nDotL > 0.0) {
                specularBase = clamp(dot(reflectedLightDir, toCamDir), 0.0, 1.0);
            }
            float specularGloss = pow(specularBase, 32.0);
            vec3 specular = specularColor * specularGloss;
            float specBase = clamp(dot(reflectedLightDir, toCamDir), 0.0, 1.0);
            float spec = pow(specBase, 16.0);
            if (u_Count == 3) {
                spec *= 0.5;
            }

            //gl_FragColor = vec4(diffuse * visibility, 1.0);

            vec4 sample = texture2D(u_Sampler, v_UV);
            vec3 I = normalize(v_Position.xyz - vec3(u_CamPosX, u_CamPosY, u_CamPosZ));
            vec3 R = reflect(I, normal);
            vec4 refTex = textureCube(u_Skybox, R);
            vec3 base = vec3((diffuse + spec + ambient) * visibility * sample.rgb);

            if (u_Count == 1) {
                gl_FragColor = vec4(mix(base, refTex.rgb, 0.32), 1.0);
            }
            else if (u_Count == 2) {
                gl_FragColor = vec4(mix(base, refTex.rgb, 0.7), 1.0);
            }
            else {
                gl_FragColor = vec4(base, 1.0);
            }
        }
    }
    `;

var normalProgram, shadowProgram;

var modelTable;
var modelDao;
var modelKing;
var modelAircon;

function main(){
    loadJSONResource('models/table.json', function(modelErr, modelObj){
        modelTable = modelObj;
        setTimeout(function(){
            loadObj1();
        },500);
    });
}

function loadObj1() {
    loadJSONResource('models/dao.json', function(modelErr, modelObj){
        modelDao = modelObj;
        setTimeout(function(){
            loadObj2();
        },500);
    });
}

function loadObj2() {
    loadJSONResource('models/king.json', function(modelErr, modelObj){
        modelKing = modelObj;
        setTimeout(function(){
            loadObj3();
        },500);
    });
}

function loadObj3() {
    loadJSONResource('models/aircon.json', function(modelErr, modelObj){
        modelAircon = modelObj;
        setTimeout(function(){
            start();
        },500);
    });
}

function start(){
    console.log("Hello World");
    var canvas = document.getElementById('webgl');
    //var gl = getWebGLContext(canvas);
    var gl = canvas.getContext("webgl", {antialias: true});

    //Load browser extension for better texture filtering
    gl.anisotropyExt = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");

    //initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE);
    
    // Initialize shaders for generating a shadow map
    shadowProgram = createProgram(gl, SHADOW_VSHADER_SOURCE, SHADOW_FSHADER_SOURCE);
    shadowProgram.a_Position = gl.getAttribLocation(shadowProgram, 'a_Position');
    shadowProgram.u_MvpMatrix = gl.getUniformLocation(shadowProgram, 'u_MvpMatrix');

    // Initialize shaders for regular drawing
    normalProgram = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
    normalProgram.a_Position = gl.getAttribLocation(normalProgram,'a_Position');
    normalProgram.a_Color = gl.getAttribLocation(normalProgram,'a_Color');
    normalProgram.a_UV = gl.getAttribLocation(normalProgram, 'a_UV');
    normalProgram.a_Normal = gl.getAttribLocation(normalProgram, 'a_Normal');
    normalProgram.a_Tangent = gl.getAttribLocation(normalProgram, 'a_Tangent');
    normalProgram.a_Bitangent = gl.getAttribLocation(normalProgram, 'a_Bitangent');
    
    normalProgram.u_ModelMatrix = gl.getUniformLocation(normalProgram,'u_ModelMatrix');
    normalProgram.u_ViewMatrix = gl.getUniformLocation(normalProgram,'u_ViewMatrix');
    normalProgram.u_ProjMatrix = gl.getUniformLocation(normalProgram,'u_ProjMatrix');
    normalProgram.u_MvpMatrixFromLight = gl.getUniformLocation(normalProgram, 'u_MvpMatrixFromLight');
    normalProgram.u_ShadowMap = gl.getUniformLocation(normalProgram,'u_ShadowMap');
    normalProgram.u_Time = gl.getUniformLocation(normalProgram, 'u_Time');
    normalProgram.u_Count = gl.getUniformLocation(normalProgram, 'u_Count');
    normalProgram.u_LightPosX = gl.getUniformLocation(normalProgram, 'u_LightPosX');
    normalProgram.u_LightPosY = gl.getUniformLocation(normalProgram, 'u_LightPosY');
    normalProgram.u_LightPosZ = gl.getUniformLocation(normalProgram, 'u_LightPosZ');
    normalProgram.u_LightR = gl.getUniformLocation(normalProgram, 'u_LightR');
    normalProgram.u_LightG = gl.getUniformLocation(normalProgram, 'u_LightG');
    normalProgram.u_LightB = gl.getUniformLocation(normalProgram, 'u_LightB');
    normalProgram.u_CamPosX = gl.getUniformLocation(normalProgram, 'u_CamPosX');
    normalProgram.u_CamPosY = gl.getUniformLocation(normalProgram, 'u_CamPosY');
    normalProgram.u_CamPosZ = gl.getUniformLocation(normalProgram, 'u_CamPosZ');
    normalProgram.u_Skybox = gl.getUniformLocation(normalProgram, 'u_Skybox');

    gl.useProgram(normalProgram);

    // Initialize framebuffer object (FBO)
    var fbo = initFramebufferObject(gl);
    gl.activeTexture(gl.TEXTURE3); // Set a texture object to the texture unit
    gl.bindTexture(gl.TEXTURE_2D, fbo.texture);

    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);

    // Matrices
    var modelMatrix = new Matrix4();
    var viewMatrix = new Matrix4();
    var projMatrix = new Matrix4();
    var mvpMatrixFromLight = new Matrix4(); // A model view projection matrix from light source (for plane)
    var viewProjMatrixFromLight = new Matrix4(); // Prepare a view projection matrix for generating a shadow map

    // Meshes
    var skyCube = initCube(gl);
    var table = initVertexBuffers(gl, modelTable);
    var dao = initVertexBuffers(gl, modelDao);
    var king = initVertexBuffers(gl, modelKing);
    var aircon = initVertexBuffers(gl, modelAircon);

    // Textures
    var sky = loadCubeMap(gl, skyLeft, skyRight, skyTop, skyBtm, skyFront, skyBack);
    var tableColor = initTextures(gl, normalProgram, 'textures/m_table_Base_color.png', 0);
    var daoColor = initTextures(gl, normalProgram, 'textures/m_dao_Base_color.png', 0);
    var airconColor = initTextures(gl, normalProgram, 'textures/m_aircon_Base_color.png', 0);
    var kingColor = initTextures(gl, normalProgram, 'textures/m_king_Base_color.png', 0);
    var tableNormal = initTextures(gl, normalProgram, 'textures/m_table_Normal_OpenGL.png', 1);
    var daoNormal = initTextures(gl, normalProgram, 'textures/m_dao_Normal_OpenGL.png', 1);
    var airconNormal = initTextures(gl, normalProgram, 'textures/m_aircon_Normal_OpenGL.png', 1);
    var kingNormal = initTextures(gl, normalProgram, 'textures/m_king_Normal_OpenGL.png', 1);

    var tick = function() {

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        TIME += 0.005;
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //////////////////////////
        // BEGIN SHADOW RENDER //
        ////////////////////////
        gl.useProgram(shadowProgram);
        gl.disable(gl.CULL_FACE);

        viewProjMatrixFromLight.setOrtho(-4,4,-4,4, 0.1,9.0);
        viewProjMatrixFromLight.lookAt(0, 3.0, 5, 0, 0, 0, 0, 1, 0);
        
        // BEGIN Drawing
            // Table
            setupBuffers(gl, shadowProgram, table, true);
            modelMatrix.setIdentity();
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(shadowProgram.u_MvpMatrix, false, mvpMatrixFromLight.elements); 
            gl.drawElements(gl.TRIANGLES, table.numIndices, table.indexBuffer.type, 0);

            // Dao
            setupBuffers(gl, shadowProgram, dao, true);
            modelMatrix.setIdentity();
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(shadowProgram.u_MvpMatrix, false, mvpMatrixFromLight.elements); 
            gl.drawElements(gl.TRIANGLES, dao.numIndices, dao.indexBuffer.type, 0);

            // King
            setupBuffers(gl, shadowProgram, king, true);
            modelMatrix.setIdentity();
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(shadowProgram.u_MvpMatrix, false, mvpMatrixFromLight.elements); 
            gl.drawElements(gl.TRIANGLES, king.numIndices, king.indexBuffer.type, 0);

            // Aircon
            setupBuffers(gl, shadowProgram, aircon, true);
            modelMatrix.setIdentity();
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(shadowProgram.u_MvpMatrix, false, mvpMatrixFromLight.elements); 
            gl.drawElements(gl.TRIANGLES, aircon.numIndices, aircon.indexBuffer.type, 0);

        // END Drawing
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);

        ///////////////////////////
        // BEGIN REGULAR RENDER //
        /////////////////////////
        gl.useProgram(normalProgram);
        gl.uniform1i(normalProgram.u_ShadowMap, 0);
        gl.uniform1i(normalProgram.u_Skybox, 2);
        
        gl.uniform1f(normalProgram.u_CamPosX, camPosX);
        gl.uniform1f(normalProgram.u_CamPosY, camPosY);
        gl.uniform1f(normalProgram.u_CamPosZ, camPosZ);

        gl.uniform1f(normalProgram.u_Time, TIME);
        gl.uniform1f(normalProgram.u_CamPosX, camPosX);
        gl.uniform1f(normalProgram.u_CamPosY, camPosY);
        gl.uniform1f(normalProgram.u_CamPosZ, camPosZ);

        // Camera
        // https://learnopengl.com/Getting-started/Camera
        groundHeight = 0;
        camPosY = groundHeight + 0.5;
        if (jumping === true) {
            dt = TIME - startTime;
            const g = 0.5;
            camPosY += 1.0 * velY * dt;
            velY -= g * dt;
            if (camPosY <= groundHeight + 0.5) {
                velY = 0;
                jumping = false;
            }
        }

        viewMatrix.setLookAt(camPosX, camPosY, camPosZ,   Math.cos(yaw) * Math.cos(toRads(pitch)) + camPosX, Math.sin(toRads(pitch)) + camPosY, Math.sin(yaw) * Math.cos(toRads(pitch)) + camPosZ,  0.0, 1.0, 0.0);
        gl.uniformMatrix4fv(normalProgram.u_ViewMatrix, false, viewMatrix.elements);

        // Viewing volume
        projMatrix.setPerspective(50, canvas.width/canvas.height, 0.1, 7500);
    
        gl.uniformMatrix4fv(normalProgram.u_ProjMatrix, false, projMatrix.elements);

        // BEGIN Drawing
            gl.activeTexture(gl.TEXTURE3);
            gl.bindTexture(gl.TEXTURE_2D, fbo.texture);
            gl.uniform1i(normalProgram.u_ShadowMap, 3);

            // Table
            gl.uniform1i(normalProgram.u_Count, 3);
            setupBuffers(gl, normalProgram, table);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tableColor);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, tableNormal);
            modelMatrix.setIdentity();
            gl.uniformMatrix4fv(normalProgram.u_ModelMatrix, false, modelMatrix.elements);
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight.elements);
            gl.drawElements(gl.TRIANGLES, table.numIndices, table.indexBuffer.type, 0);

            // Dao
            gl.uniform1i(normalProgram.u_Count, 1);
            setupBuffers(gl, normalProgram, dao);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, daoColor);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, daoNormal);
            modelMatrix.setIdentity();
            gl.uniformMatrix4fv(normalProgram.u_ModelMatrix, false, modelMatrix.elements);
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight.elements);
            gl.drawElements(gl.TRIANGLES, dao.numIndices, dao.indexBuffer.type, 0);

            // King
            gl.uniform1i(normalProgram.u_Count, 2);
            setupBuffers(gl, normalProgram, king);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, kingColor);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, kingNormal);
            modelMatrix.setIdentity();
            gl.uniformMatrix4fv(normalProgram.u_ModelMatrix, false, modelMatrix.elements);
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight.elements);
            gl.drawElements(gl.TRIANGLES, king.numIndices, king.indexBuffer.type, 0);

            // Aircon
            gl.uniform1i(normalProgram.u_Count, 3);
            setupBuffers(gl, normalProgram, aircon);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, airconColor);
            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, airconNormal);
            modelMatrix.setIdentity();
            gl.uniformMatrix4fv(normalProgram.u_ModelMatrix, false, modelMatrix.elements);
            mvpMatrixFromLight.set(viewProjMatrixFromLight);
            mvpMatrixFromLight.multiply(modelMatrix);
            gl.uniformMatrix4fv(normalProgram.u_MvpMatrixFromLight, false, mvpMatrixFromLight.elements);
            gl.drawElements(gl.TRIANGLES, aircon.numIndices, aircon.indexBuffer.type, 0);

            // Skybox
            gl.depthMask(false);
            gl.cullFace(gl.FRONT);
            
            gl.uniform1i(normalProgram.u_Count, 0);
            gl.activeTexture(gl.TEXTURE2);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, sky);
            gl.uniform1i(normalProgram.u_Skybox, 2);
            
            bindSet(gl, skyCube.vertexBuffer, normalProgram.a_Position, 3);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, skyCube.indexBuffer);
            
            modelMatrix.setIdentity();
            modelMatrix.translate(camPosX, camPosY, camPosZ);
            modelMatrix.scale(4000, 4000, 4000);
            modelMatrix.rotate(-90.0, 0, 1, 0);
            gl.uniformMatrix4fv(normalProgram.u_ModelMatrix, false, modelMatrix.elements)
            gl.drawElements(gl.TRIANGLES, skyCube.count, gl.UNSIGNED_SHORT, 0);

            gl.cullFace(gl.BACK);
            gl.depthMask(true);
        // END drawing

        if (dollyInFlag) { dollyIn() };
        if (dollyOutFlag) { dollyOut() };
        if (tiltUpFlag) { tiltUp() };
        if (tiltDownFlag) { tiltDown() };
        if (panLeftFlag) { panLeft() };
        if (panRightFlag) { panRight() };

        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        requestAnimationFrame(tick, canvas);
    }
    tick();
}

function initVertexBuffers(gl, model) {
    console.log(model);

    var vertices = new Float32Array(model.meshes[0].vertices);
    var texCoords = new Float32Array(model.meshes[0].texturecoords[0]);
    var normals = new Float32Array(model.meshes[0].normals);
    var tangents = new Float32Array(model.meshes[0].tangents);
    var bitangents = new Float32Array(model.meshes[0].bitangents);
    var indices = new Uint16Array([].concat.apply([], model.meshes[0].faces));
    var o = new Object(); // Utilize Object to to return multiple buffer objects together

    // Write vertex information to buffer object
    o.vertexBuffer = initArrayBufferForLaterUse(gl, vertices, 3, gl.FLOAT);
    o.texCoordBuffer = initArrayBufferForLaterUse(gl, texCoords, 2, gl.FLOAT);
    o.normalBuffer = initArrayBufferForLaterUse(gl, normals, 3, gl.FLOAT);
    o.tangentBuffer = initArrayBufferForLaterUse(gl, tangents, 3, gl.FLOAT);
    o.bitangentBuffer = initArrayBufferForLaterUse(gl, bitangents, 3, gl.FLOAT);
    o.indexBuffer = initElementArrayBufferForLaterUse(gl, indices, gl.UNSIGNED_SHORT);
    o.numIndices = indices.length;

    // Unbind the buffer object
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

    return o;
}

function setupBuffers(gl, program, o, posOnly=false) {
    var a_Position = gl.getAttribLocation(program,'a_Position');
    initAttributeVariable(gl, a_Position, o.vertexBuffer);  
    if (!posOnly) {
        var a_Normal = gl.getAttribLocation(program,'a_Normal');
        var a_TexCoord = gl.getAttribLocation(program,'a_UV');
        var a_Tangent = gl.getAttribLocation(program,'a_Tangent');
        var a_Bitangent = gl.getAttribLocation(program,'a_Bitangent');
        initAttributeVariable(gl, a_Normal, o.normalBuffer);  
        initAttributeVariable(gl, a_TexCoord, o.texCoordBuffer);
        initAttributeVariable(gl, a_Tangent, o.tangentBuffer);
        initAttributeVariable(gl, a_Bitangent, o.bitangentBuffer);
    }
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, o.indexBuffer); 
}

// Assign the buffer objects and enable the assignment
function initAttributeVariable(gl, a_attribute, buffer) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(a_attribute, buffer.num, buffer.type, false, 0, 0);
    gl.enableVertexAttribArray(a_attribute);
}

function initElementArrayBufferForLaterUse(gl, data, type) {
    var buffer = gl.createBuffer();  // Create a buffer object
    // Write date into the buffer object
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);
    buffer.type = type;
    return buffer;
}

function initArrayBufferForLaterUse(gl, data, num, type) {
    var buffer = gl.createBuffer();   // Create a buffer object
    // Write data into the buffer object
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    // Keep the information necessary to assign to the attribute variable later
    buffer.num = num;
    buffer.type = type;
    return buffer;
}

function initCube(gl) {
    var vertices = new Float32Array([   // Vertex coordinates
        1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0,  // v0-v1-v2-v3 front
        1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0,  // v0-v3-v4-v5 right
        1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0,  // v0-v5-v6-v1 up
        -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0,  // v1-v6-v7-v2 left
        -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0,  // v7-v4-v3-v2 down
        1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0   // v4-v7-v6-v5 back
    ]);
    
    var indices = new Uint16Array([ // Indices of the vertices
        0, 1, 2,   0, 2, 3,    // front
        4, 5, 6,   4, 6, 7,    // right
        8, 9,10,   8,10,11,    // up
        12,13,14,  12,14,15,    // left
        16,17,18,  16,18,19,    // down
        20,21,22,  20,22,23     // back
    ]);

    var normals = new Float32Array([    // Normals
        0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,   0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
        1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,   1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
        0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,   0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
        -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
        0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,   0.0,-1.0, 0.0,  // v7-v4-v3-v2 down
        0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0,   0.0, 0.0,-1.0   // v4-v7-v6-v5 back
    ]);
    
    var vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    
    var indexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    
    return {vertexBuffer,indexBuffer, count: indices.length};
}

function initFramebufferObject(gl) {
  var framebuffer, texture, depthBuffer;

  // Create a framebuffer object (FBO)
  framebuffer = gl.createFramebuffer();

  // Create a texture object and set its size and parameters
  texture = gl.createTexture(); // Create a texture object
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

  // Create a renderbuffer object and Set its size and parameters
  depthBuffer = gl.createRenderbuffer(); // Create a renderbuffer object
  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);

  // Attach the texture and the renderbuffer object to the FBO
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

  // Check if FBO is configured correctly
  var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  framebuffer.texture = texture; // keep the required object

  // Unbind the buffer object
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);

  return framebuffer;
}

function loadCubeMap(gl, left, right, top, btm, front, back) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    
    var faces = [[right,  gl.TEXTURE_CUBE_MAP_POSITIVE_X],
                 [left,   gl.TEXTURE_CUBE_MAP_NEGATIVE_X],
                 [top,    gl.TEXTURE_CUBE_MAP_POSITIVE_Y],
                 [btm,    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y],
                 [front,  gl.TEXTURE_CUBE_MAP_POSITIVE_Z],
                 [back,   gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]];
                 
    for (var i = 0; i < faces.length; i++) {
        var face = faces[i][1];
        var image = new Image();
        image.onload = function(texture, face, image) {
            return function() {
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                gl.texImage2D(face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            }
        } (texture, face, image);
        image.src = faces[i][0];
    }
    return texture;
}

function initTextures(gl, program, imSrc, texUnit) {

    var texture = gl.createTexture();   // Create a texture object
    var image = new Image();  // Create a image object

    // Register the event handler to be called when image loading is completed
    image.onload = function() {
        // Write the image data to texture object
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);  // Flip the image Y coordinate
        if(texUnit == 0){
            gl.activeTexture(gl.TEXTURE0);
        }else{
            gl.activeTexture(gl.TEXTURE1);
        }
        gl.bindTexture(gl.TEXTURE_2D, texture);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        let max = gl.getParameter(gl.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        gl.texParameterf(gl.TEXTURE_2D, gl.anisotropyExt.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(4, max));
        gl.generateMipmap(gl.TEXTURE_2D);

        // Pass the texure unit 0 to u_Sampler
        if(texUnit == 0){
            program.u_Sampler = gl.getUniformLocation(program, 'u_Sampler');
            gl.uniform1i(program.u_Sampler, 0);
        }else{
            program.u_NormalMap = gl.getUniformLocation(program, 'u_NormalMap');
            gl.uniform1i(program.u_NormalMap, 1);
        }
        gl.bindTexture(gl.TEXTURE_2D, null); // Unbind texture
    };
    // Tell the browser to load an Image
    image.src = imSrc;
    return texture;
}

function computeTB(p0, p1, p2, uv0, uv1, uv2) {
    var edge1 = [p1[0] - p0[0], p1[1] - p0[1], p1[2] - p0[2]];
    var edge2 = [p2[0] - p0[0], p2[1] - p0[1], p2[2] - p0[2]];

    var deltaUV1 = [uv1[0] - uv0[0], uv1[1] - uv0[1]];
    var deltaUV2 = [uv2[0] - uv0[0], uv2[1] - uv0[1]];

    var f = 1.0 / (deltaUV1[0]*deltaUV2[1] - deltaUV2[0]*deltaUV1[1]);

    var tangent1X = f * (deltaUV2[1] * edge1[0] - deltaUV1[1] * edge2[0]);
    var tangent1Y = f * (deltaUV2[1] * edge1[1] - deltaUV1[1] * edge2[1]);
    var tangent1Z = f * (deltaUV2[1] * edge1[2] - deltaUV1[1] * edge2[2]);

    var bitangent1X = f * (-deltaUV2[0] * edge1[0] + deltaUV1[0] * edge2[0]);
    var bitangent1Y = f * (-deltaUV2[0] * edge1[1] + deltaUV1[0] * edge2[1]);
    var bitangent1Z = f * (-deltaUV2[0] * edge1[2] + deltaUV1[0] * edge2[2]);

    tangent = [tangent1X, tangent1Y, tangent1Z];
    bitangent = [bitangent1X, bitangent1Y, bitangent1Z];

    return {tangent, bitangent};
}

function bindSet(gl, buffer, attribute, num) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(attribute, num, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(attribute);
}

function jump() {
    if (jumping) {
        return;
    }
    startTime = TIME;
    velY = 10.0;
    jumping = true;
}

function toRads(degree) {
    return degree * (Math.PI / 180.0);
}

function dollyOut() {
    camPosZ -= Math.sin(yaw) * 0.02;
    camPosX -= Math.cos(yaw) * 0.02;
    if (orthoView) {
        orthoPos += 0.2;
    }
}

function dollyIn() {
    camPosZ += Math.sin(yaw) * 0.02;
    camPosX += Math.cos(yaw) * 0.02;
    if (orthoView) {
        orthoPos -= 0.2;
    }
}

function panLeft() {
    yaw -= 0.1 / 8.0;
}

function panRight() {
    yaw += 0.1 / 8.0;
}

function tiltUp() {
    pitch += 0.5;
    if (pitch > 89.0) {
        pitch = 89.0;
    }
}

function tiltDown() {
    pitch -= 0.5;
    if (pitch < -89.0) {
        pitch = -89.0;
    }
}

function toggleOrtho() {
    orthoView = !orthoView;
}

// Globals
var yaw = toRads(270.0);
var pitch = 0.0;
var camPosX = 0.0;
var camPosY = 0.0;
var camPosZ = 4.0;
var orthoView = false;
var orthoPos = 2.0;
var velY = 0.0;
var jumping = false;
var TIME = 0.0;
var startTime;

var dollyInFlag = false, dollyOutFlag = false;
var panLeftFlag = false, panRightFlag = false;
var tiltUpFlag = false, tiltDownFlag = false;

const skyRight = "textures/vz_clear_ocean_right.png";  
const skyLeft = "textures/vz_clear_ocean_left.png";  
const skyTop = "textures/vz_clear_ocean_up.png";  
const skyBtm = "textures/vz_clear_ocean_down.png";  
const skyFront = "textures/vz_clear_ocean_front.png";
const skyBack = "textures/vz_clear_ocean_back.png";

const OFFSCREEN_HEIGHT = 2048, OFFSCREEN_WIDTH = 2048;

var xSlider = document.getElementById("xRange");
var ySlider = document.getElementById("yRange");
var zSlider = document.getElementById("zRange");
var rSlider = document.getElementById("rRange");
var gSlider = document.getElementById("gRange");
var bSlider = document.getElementById("bRange");

document.addEventListener('keydown', (e) => {
    if (e.code === "KeyS") {
        dollyOutFlag = true;
    }
    else if (e.code === "KeyW") {
        dollyInFlag = true;
    }
    else if (e.code === "ArrowLeft") {
        panLeftFlag = true;
    }
    else if (e.code === "ArrowRight") {
        panRightFlag = true;
    }
    else if (e.code === "ArrowUp") {
        tiltUpFlag = true;
    }
    else if (e.code === "ArrowDown") {
        tiltDownFlag = true;
    }
    else if (e.code === "Space") {
        jump();
    }
})

document.addEventListener('keyup', (e) => {
    if (e.code === "KeyS") {
        dollyOutFlag = false;
    }
    else if (e.code === "KeyW") {
        dollyInFlag = false;
    }
    else if (e.code === "ArrowLeft") {
        panLeftFlag = false;
    }
    else if (e.code === "ArrowRight") {
        panRightFlag = false;
    }
    else if (e.code === "ArrowUp") {
        tiltUpFlag = false;
    }
    else if (e.code === "ArrowDown") {
        tiltDownFlag = false;
    }
})

</script>

</head>

<!-- When page loads, call main() in Javascript. -->
<body onload="main();">

<!-- The Window that displays graphics. -->
<canvas id="webgl" width="1800" height="1000"></canvas>

<br> <!-- Newline -->

<button type="button" onclick="panLeft()">Left</button>
<button type="button" onclick="panRight()">Right</button>
<button type="button" onclick="dollyIn()">Forward (w)</button>
<button type="button" onclick="dollyOut()">Backward (s)</button>
<button type="button" onclick="tiltUp()">Up</button>
<button type="button" onclick="tiltDown()">Down</button>

</body>
</html>
